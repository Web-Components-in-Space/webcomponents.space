<canvas id="shader"></canvas>
<style>
    #shader {
        position: fixed;
        z-index: -9999;
    }
</style>
<script>
  const canvas: HTMLCanvasElement = document.getElementById('shader') as HTMLCanvasElement;
  const gl: WebGLRenderingContext = canvas?.getContext('webgl') as WebGLRenderingContext;

  const startTime = new Date().getTime() / 1000;
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);

  const vertexShaderSource = `
  attribute vec2 position;
  void main() {
  gl_Position = vec4(position, 0.0, 1.0);
}
  `;

  const fragmentShaderSource = `
  precision mediump float;
  uniform vec2 resolution;
  uniform float time;

  vec3 glitchyColor(float value) {
  return vec3(
  value * (0.5 + 0.5 * sin(time * 4.0)),
  value * (0.5 + 0.5 * sin(time * 3.0 + 2.0)),
  value * (0.5 + 0.5 * sin(time * 2.0 + 4.0))
  );
}

  void main() {
  vec2 uv = gl_FragCoord.xy / resolution;
  float t = time * 0.5;

  float wave1 = sin(uv.x * 20.0 + t * 4.0);
  float wave2 = sin(uv.y * 30.0 + t * 3.0);
  float wave3 = sin((uv.x + uv.y) * 15.0 + t * 2.0);
  float waveSum = wave1 + wave2 + wave3;

  float finalValue = step(0.9, waveSum);

  vec3 bgColor = vec3(0.1, 0.1, 0.1);
  vec3 fgColor = glitchyColor(finalValue);

  gl_FragColor = vec4(mix(bgColor, fgColor, smoothstep(0.1, 0.9, finalValue)), 1.0);
}
  `;

  function createShader(gl: WebGLRenderingContext, type: number, source: string) {
      const shader: WebGLShader = gl.createShader(type) as WebGLShader;
      gl.shaderSource(shader, source);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error('An error occurred compiling the shaders:', gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }

      return shader;
    }

  const vertexShader: string = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource) as string;
  const fragmentShader: string = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource) as string;

  const program: WebGLProgram = gl.createProgram() as WebGLProgram;
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);

  if (!gl.getProgramParameter(program as WebGLProgram, gl.LINK_STATUS)) {
  console.error('Unable to initialize the shader program:', gl.getProgramInfoLog(program as WebGLProgram));
}

  gl.useProgram(program);

  const timeUniformLocation = gl.getUniformLocation(program as WebGLProgram, 'time');
  const positionAttributeLocation = gl.getAttribLocation(program as WebGLProgram, 'position');
  const resolutionUniformLocation = gl.getUniformLocation(program as WebGLProgram, 'resolution');

  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

  gl.enableVertexAttribArray(positionAttributeLocation);
  gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

  gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);

  function animate() {
  const currentTime = new Date().getTime() / 1000 - startTime;
  gl.uniform1f(timeUniformLocation, currentTime);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(animate);
}

animate();
</script>